import { AnonymizationStrategyInterface, AnonProxyConfig } from '../core/types';
import { CryptoUtils } from '../utils/crypto';

/**
 * Hash + Salt anonymization strategy
 * Fast, reversible, and secure for most use cases
 */
export class HashSaltStrategy implements AnonymizationStrategyInterface {
  private salt: string;

  constructor(customSalt?: string) {
    // Use custom salt or generate a new one
    this.salt = customSalt || CryptoUtils.generateSalt();
  }

  /**
   * Anonymize a token using hash + salt
   * @param token - Original sensitive token
   * @param config - Configuration options
   * @returns Anonymous proxy token
   */
  async anonymize(token: string, config: AnonProxyConfig): Promise<string> {
    try {
      if (!token || typeof token !== 'string') {
        throw new Error('Token must be a non-empty string');
      }

      // Use custom salt from config if provided, otherwise use instance salt
      const saltToUse = config.customSalt || this.salt;
      
      // Generate proxy token with configurable prefix
      const proxyToken = CryptoUtils.generateProxyToken(token, saltToUse, 'anon_');

      if (config.enableLogging) {
        // eslint-disable-next-line no-console
        console.log(`[HashSaltStrategy] Anonymized token (length: ${token.length}) -> ${proxyToken}`);
      }

      return proxyToken;
      
    } catch (error) {
      throw new Error(`Hash-salt anonymization failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Check if this strategy can reverse the anonymization
   * Hash + salt is reversible because we maintain the mapping
   */
  isReversible(): boolean {
    return true;
  }

  /**
   * Get the salt used by this strategy
   * @returns The salt string
   */
  getSalt(): string {
    return this.salt;
  }

  /**
   * Update the salt used by this strategy
   * @param newSalt - New salt to use
   */
  setSalt(newSalt: string): void {
    if (!newSalt || typeof newSalt !== 'string') {
      throw new Error('Salt must be a non-empty string');
    }
    this.salt = newSalt;
  }

  /**
   * Validate that a proxy token was generated by this strategy
   * @param proxyToken - Proxy token to validate
   * @param originalToken - Original token to check against
   * @param saltToUse - Salt to use for validation (optional)
   * @returns True if the proxy token is valid for the original token
   */
  validateProxy(proxyToken: string, originalToken: string, saltToUse?: string): boolean {
    try {
      const salt = saltToUse || this.salt;
      const expectedProxy = CryptoUtils.generateProxyToken(originalToken, salt, 'anon_');
      return CryptoUtils.constantTimeCompare(proxyToken, expectedProxy);
    } catch (error) {
      return false;
    }
  }

  /**
   * Generate multiple proxy tokens with different salts for testing
   * @param token - Original token
   * @param count - Number of proxies to generate
   * @returns Array of proxy tokens with their salts
   */
  generateMultipleProxies(token: string, count: number = 3): Array<{ proxy: string; salt: string }> {
    try {
      const results: Array<{ proxy: string; salt: string }> = [];
      
      for (let i = 0; i < count; i++) {
        const salt = CryptoUtils.generateSalt();
        const proxy = CryptoUtils.generateProxyToken(token, salt, 'anon_');
        results.push({ proxy, salt });
      }

      return results;
      
    } catch (error) {
      throw new Error(`Failed to generate multiple proxies: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Estimate the collision probability for a given token space
   * @param tokenSpace - Estimated number of unique tokens
   * @param hashOutputBits - Number of bits in the hash output (default: 128 for first 16 chars)
   * @returns Collision probability (0-1)
   */
  estimateCollisionProbability(tokenSpace: number, hashOutputBits: number = 128): number {
    try {
      // Using birthday paradox approximation
      const hashSpaceSize = Math.pow(2, hashOutputBits);
      const probability = 1 - Math.exp(-(tokenSpace * tokenSpace) / (2 * hashSpaceSize));
      return Math.min(1, probability);
    } catch (error) {
      return 1; // Assume high probability on error
    }
  }

  /**
   * Get strategy information and statistics
   * @returns Strategy metadata
   */
  getInfo(): {
    name: string;
    version: string;
    isReversible: boolean;
    saltLength: number;
    security: {
      hashAlgorithm: string;
      saltBits: number;
      outputFormat: string;
    };
  } {
    return {
      name: 'Hash + Salt Strategy',
      version: '1.0.0',
      isReversible: this.isReversible(),
      saltLength: this.salt.length,
      security: {
        hashAlgorithm: 'SHA-256',
        saltBits: 256, // 32 bytes * 8 bits/byte
        outputFormat: 'Base64 truncated to 16 characters'
      }
    };
  }
}
